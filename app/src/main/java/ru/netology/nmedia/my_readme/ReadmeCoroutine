1. Coroutine (корутины), или сопрограммы — это блоки кода, которые работают асинхронно, то есть по очереди.
В нужный момент исполнение такого блока приостанавливается с сохранением всех его свойств,
чтобы запустился другой код. Когда управление возвращается к первому блоку, он продолжает работу.

2.Что дает Coroutine?
- упрощение и уменьшение кода.
- Когда корутина приостанавливается (suspend), поток*, на котором она исполнялась,
 не блокируется (т.е. может выполнять другую работу - другие корутины).
- Корутины можно использовать для того, чтобы удобно и последовательно выполнять асинхронные операции
(например, несколько последовательных НТТР-запросов)
- Корутины можно использовать для организации параллелизма (параллельно запустить несколько НТТР-запросов)

3.Что нужно, чтобы использовать корутины?
- подключить библиотеку: implementation( dependencyNotation: "org. jetbrains.kotlinx:kotlinx-conoutines-cone: 1.4.3 ")

4.Что нужно, что бы запустить корутины?
-нужно использовать спец функции, которые называются Coroutine Builders:
Вот небольшой список:
•	runBlocking
Функция runBlocking блокирует вызывающий поток, пока все корутины внутри вызова runBlocking {...} не завершат свое выполнение.
•	launch
запускает корутин, но ничего не возвращает
Все билдеры корутин, такие как launch и async, принимают необязательный параметр CoroutineContext,
который можно использовать для явного указания диспетчера для новой корутины и других элементов контекста.
•	async
возвращает экземпляр Deferred, в котором имеется функция await(), которая возвращает результат корутины
•	produce
Шаблон, в котором сопрограмма создает последовательность элементов

-----далее кирдых по лекции. нужно изучить на стороне--------

5.CoroutineContext - это immutable объект (Immutable объект - это объект, состояние которого после
 создания невозможно изменить), содержащий различные вспомогательные объекты, которые
«прикрепляются» к корутине и отвечают за:
  •	политику распределения по потокам
  •	логирование
  •	идентификацию и т.д.
  Ключевое: в этом интерфейсе переопределены операторы:
  •	[key] - get (позволяет по ключу доставать значение)
  •	+ - plus (позволяет создавать новый контекст, на базе предыдущего + дополнения):
  interface CoroutineContext {
  operator fun <E : Element> get(key: Key<E>): E? fun <R> fold(initial: R, operation: (R, Element) -> R)
  : R operator fun plus(context: CoroutineContext): CoroutineContext fun minusKey(key: Key<*>): CoroutineContext

  Стандартная библиотека предоставляет EmptyCoroutineContext, который не содержит никаких элементов.
  Все билдеры корутин, такие как launch и async, принимают необязательный параметр CoroutineContext,
  который можно использовать для явного указания диспетчера для новой корутины и других элементов контекста.

6.Suspension points - это точки, в которых может быть приостановлено выполнение корутины
(т.е. Kotlin не сам каким-то магическим образом ставит на паузу выполнение, он это может сделать
в специальных точках). Один из примеров - вызов suspend функции.

7.Нужно создать область видимости для корутин
Есть готовые функции для создания:
•	CoroutineScope
CoroutineScope это suspend-функция, которая создаёт новый скоуп и идёт дальше только после его
завершения и не привязывается к родительскому скоупу. Когда скоуп, созданный coroutineScope, упал,
падает сама suspend-функция, а не весь родительский scope.
P/S(Scope-функции (можно перевести как "функции контекста" или "функции области видимости") позволяют
 выполнить для некоторого объекта некоторый код в виде лямбда-выражение. При вызове подобной функции,
 создается временная область видимости. В этой области видимости можно обращаться к объекту без
 использования его имени.)
•	MainScope
MainScope это CoroutineScopeприложение, которое Dispatchers.Mainпо умолчанию использует диспетчер,
 который привязан к основному потоку пользовательского интерфейса.
•	а также синглтон GlobalScope (которым не стоит увлекаться)
GlobalScope — жизненные рамки для корутины. В данном случае корутина будет жить, пока живо
приложение, в котором она запущена. GlobalScope — конкретная реализация интерфейса CoroutineScope.
Можно реализовать свой scope, например, в Activity, и это приведет к тому, что запущенные в Activity
корутины будут автоматически отменяться в случае завершения или краша Activity.


8.Сontinuation
Это интерфейс, который содержит некий контекст (информацию), имеющий три функции: 1.resumeWith,
которая возобновляет выполнение корутины с последней точки остановки. При это выдаст удачный или
неудачный результат. 2.resume, которая  возобновляет выполнение корутины с последней точки остановки.
 При это выдаст  результат с последней точки остановки. 3.resumeWithException возобновляет
 выполнение корутины с последней точки остановки. При это выдаст исключение

 9.Dispatcher - это диспетчер, который определяет, в соответствии с какой логикой будет
 распределяться выполнение корутины по потокам:
   •	Default - для CPU-интенсивных задач, содержит пул тредов в равным количеству ядер процессора*, но, как минимум, 2.
   •	I0 - network/files, содержит пул тредов тах(64, кол-во ядер)
   systemProp(IO_PARALLELISM_PROPERTY_l\IAME, 64.coerceAtLeast(AVAILABLE_PROCESSORS)),
   •	Main - UI (для приложений с Ul - Android, Swing, JavaFX)
   •	Unconfined - используется поток, в котором выполнялась suspend function